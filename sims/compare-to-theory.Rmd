---
title: "Comparison of simulation to theory"
date: "`r date()`"
---

```{r doc_setup, include=FALSE}
fig.dim <- 5
knitr::opts_chunk$set(fig.height=fig.dim,fig.width=2*fig.dim,fig.align='center')
source("sim-fns.R")
library(ReacTran)
library(Matrix)
source("../notes/tran.1D.R",chdir=TRUE) # fix for log.A
source("../notes/cline-fns.R",chdir=TRUE)
```

Here's the things that we'd like to have plots of simulation compared to theory for,
and might put in the paper:

1.  **Establishment of the selected cline:** the frequency of the selected allele, $p(x,t)$,
    across space, at a few times.

2.  **Conditional ancestry probabilities:** the conditional frequency of ancestry $A$
    given being linked to a selected allele of ancestry $z$, denoted $q_z(x,t,r)$,
    across space, at a few times or distances and for each $z$.

3.  **Relaxation of linked clines:** the frequency of ancestry $A$, denoted $p(x,t,r)$, 
    across space, at a few times and one or two recombination distances. 
    (This comes after $q$ because it is computed using $q$.)

4.  **Haplotype probabilities:** the probability of seeing a haplotype of length at least $\ell$
    covering position $r$ on the genome at location $x$ in space: for fixed $\ell$,
    against $r$ and/or $x$.



## Parameters from a simulation

We'll use some simulation results produced by [yaniv_sims.R](yaniv_sims.R),
and need to convert those parameters to those from theory.
Dispersal in the simulation moves as $\lfloor Z + 1/2 \rfloor$,
where $Z \sim N(0,\sigma^2_\text{demes})$;
we'll use this fact to compute the actual $\sigma$.
(Yes, that's an unbiased walk, thanks to the floor.)
Migrants past the endpoints stay there (they don't reflect).
We'll work in spatial units equal to one deme spacing;
since generations are nonoverlapping, one generation is indeed one time step in the simulation.

```{r sim_results}
simchunks.file <- "simulation_SIGMA1_Ninds25000_ndemes50_s0.1_tau100_run2016-01-11_simsums_chunks.Robj"
load(simchunks.file)  # provides 'chunks'
get_simparams <- function (fname) {
    strings <- c( sigma="SIGMA", ninds="Ninds", ndemes="ndemes", s="s", tau="tau" )
    lapply( strings, function (x) { as.numeric(gsub(sprintf(".*_%s([0-9.]+)_.*",x),"\\1",simchunks.file)) } )
}
sim.params <- get_simparams( simchunks.file )
# recombination distances, hard-coded
sim.rvals <- c(0,0.01,0.5)
# spatial locations of the demes
xx <- seq_len(sim.params$ndemes)-sim.params$ndemes/2
theory.params <- list( sigma=trueSigma(sim.params$sigma), s=sim.params$s, tau=sim.params$tau, 
       density=sim.params$ninds/sim.params$ndemes,
       width=sim.params$ndemes )
theory.params
```

*Note:* We should also work out what the actual value of **s** is.

Here are some functions we'll use to extract what we want
from data in the `chunks` format:
```{r helper_fns}
genotype_counts <- function (ch) { 
    gcounts <- t(sapply( ch, function (x) { tabulate( 1+rowSums( x>0 ), nbins=3 ) } )) 
    colnames(gcounts) <- c("AA","AB","BB")
    return(gcounts)
}
conditioned_genotype_counts <- function (x,y) { 
    # returns joint genotype counts across space from two chunks objects
    #  a (ndemes) x 4 x 4 array (4 phased genotypes)
    deme <- rep(seq_along(x),sapply(x,NROW))
    x.alleles <- ifelse(do.call(rbind,x)==0,"A","B")
    y.alleles <- ifelse(do.call(rbind,y)==0,"A","B")
    x.genotypes <- factor( paste0(x.alleles[,1],x.alleles[,2]), levels=c("AA","AB","BA","BB") )
    y.genotypes <- factor( paste0(y.alleles[,1],y.alleles[,2]), levels=c("AA","AB","BA","BB") )
    # x.genotypes <- factor( c("AA","AB","BB")[1+rowSums( do.call(rbind, x)>0 )], levels=c("AA","AB","BB") )
    # y.genotypes <- factor( c("AA","AB","BB")[1+rowSums( do.call(rbind, y)>0 )], levels=c("AA","AB","BB") )
    return( table( deme, x=x.genotypes, y=y.genotypes ) )
}
dip.to.hap <- rbind( A=c(AA=2,AB=1,BB=0), B=c(AA=0,AB=1,BB=2) )
bidip.to.bihap <- rbind(
            "A-A" = c( 2, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0 ),
            "A-B" = c( 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 2, 1, 1, 0 ),
            "B-A" = c( 0, 1, 1, 2, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0 ),
            "B-B" = c( 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 2 ) )
colnames( bidip.to.bihap ) <- as.vector( outer( c("AA","AB","BA","BB"), c("AA","AB","BA","BB"), paste, sep="-" ) )
conditional_haplotype_counts <- function (gcounts) {
    # uses output of conditioned_genotype_counts to get conditional haplotype counts
    # a (ndemes) x 2 x 2 array
    dim(gcounts) <- c(dim(gcounts)[1],prod(dim(gcounts)[2:3]))
    out <- tcrossprod( gcounts, bidip.to.bihap )
    dim(out) <- c(dim(gcounts)[1],2,2)
    dimnames(out) <- list( dimnames(gcounts)[[1]], c("A","B"), c("A","B") )
    return(out)
}
conditional_freqs <- function (gcounts) {
    # uses output of conditioned_genotype_counts to get conditional allele frequencies
    # a (ndemes) x 2 matrix
    hcounts <- conditional_haplotype_counts(gcounts)
    cbind( A = hcounts[,"A","A"]/(hcounts[,"A","A"]+hcounts[,"A","B"]),
           B = hcounts[,"A","B"]/(hcounts[,"A","B"]+hcounts[,"B","B"]) )
}
```


# Selected cline

To get the value predicted from theory, we'll solve the corresponding PDE:
```{r selected_cline_theory}
tt <- seq(0,theory.params$tau,length.out=21)
xgrid <- setup.grid.1D(x.up=-theory.params$width/2, x.down=theory.params$width/2, N=2*theory.params$width)
fgrid <- extend_grid(xgrid)
fwds.soln <- forwards_pde(s=theory.params$s, times=tt, grid=fgrid, sigma=theory.params$sigma )
```
... and, compare it to the observed values:
```{r selected_cline_sim}
gcounts <- genotype_counts(chunks[[1]])
# sim frequencies
sfreqs <- sweep( tcrossprod(gcounts,dip.to.hap), 1, 2*rowSums(gcounts), "/" )
# theory frequencies
tfreqs <- cbind( A=fwds.soln[nrow(fwds.soln),-1], B=1-fwds.soln[nrow(fwds.soln),-1] )
matplot(xx, sfreqs, type='l', lty=1, main="Selected allele frequency", ylab="frequency", xlab='geographic position')
matlines(fgrid$x.mid, tfreqs, lty=2, lwd=2)
legend("topright", legend=outer(colnames(sfreqs),c("sim","theory"),paste,sep=" : "), lty=rep(1:2,each=2), col=rep(1:ncol(sfreqs),2))
```

For fun, let's also look at genotype frequencies (is there HW?):
```{r selected_geno_freqs}
matplot(xx, sweep(gcounts,1,rowSums(gcounts),"/"), lty=1, type='l', main="Selected genotype frequencies", ylab="frequency", xlab='geographic position')
matlines(fgrid$x.mid, cbind(AA=tfreqs[,"A"]^2,AB=2*tfreqs[,"A"]*tfreqs[,"B"],BB=tfreqs[,"B"]^2), lty=4, lwd=2)
```
Looks pretty similar, just shifted.

**Question:** Is that shift due to stochasticity, or have I got the center in the wrong place on the sims?


# Ancestry probabilities

First, compute theoretical predictions at the values of $r$ in the simulation:
```{r linked_soln}
linked.solns <- lapply( sim.rvals, function (r) {
        forwards_backwards_pde(s=theory.params$s, times=tt, grid=xgrid, r=r, 
                               sigma=theory.params$sigma, fwds.soln=fwds.soln, log.p=TRUE)
    } )
```
... and compare to the observed values:
```{r compare_linked}
for (kr in seq_along(sim.rvals)[-1]) {
    gcounts <- conditioned_genotype_counts(chunks[[kr]], chunks[[1]])
    # frequencies from simulation
    cfreqs <- conditional_freqs(gcounts)
    # frequencies from theory
    tfreqs <- linked.solns[[kr]][nrow(linked.solns[[kr]]),-1]
    dim(tfreqs) <- c( length(xgrid$x.mid), 2 )
    matplot(xx, cfreqs, type='l', lty=1, main=sprintf("Frequency of A ancestry by selected background, r=%f",sim.rvals[rk]), ylab="frequency", xlab='geographic position')
    matlines(xgrid$x.mid, tfreqs, lty=2, lwd=2)
    legend("topright", legend=outer(colnames(cfreqs),c("sim","theory"),paste,sep=" : "), lty=rep(1:2,each=2), col=rep(1:ncol(sfreqs),2))
}
```
