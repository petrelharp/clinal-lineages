---
title: "Clines from PDE"
date: "`r date()`"
---

$$
\newcommand{\E}{\mathbb{E}}
\renewcommand{\P}{\mathbb{P}}
\newcommand{\R}{\mathbb{R}}
\DeclareMathOperator{\sgn}{sgn}
\newcommand{\grad}{\nabla}
$$

```{r doc_setup, include=FALSE}
fig.dim <- 5
knitr::opts_chunk$set(fig.width=2*fig.dim,fig.height=fig.dim,fig.align='center')
library(ReacTran)
library(Matrix)
source("tran.1D.R") # fix for log.A
```

*Useful functions used below:*
```{r setup_fns}
source("cline-fns.R")
```

The goal
========


Suppose that a lineage moves in a frequency profile $p(x)$ of allele $A$,
switching between backgrounds at rate $r p(x)$ or $r (1-p(x))$.
Let $(X_t,Z_t)$ denote this process,
so that
$$\begin{aligned}
    dX_t &= \grad \log(p(X_t)) dt + dB_t  \qquad \text{if } Z_t = A \\
         &= \grad \log(1-p(X_t)) dt + dB_t  \qquad \text{if } Z_t = B \\
    \P\{ Z_{t+\epsilon} = B | Z_t = A \} &= \epsilon r (1-p(X_t)) + O(\epsilon^2) \\
    \P\{ Z_{t+\epsilon} = A | Z_t = B \} &= \epsilon r p(X_t) + O(\epsilon^2) .
\end{aligned}$$
(Note that $p$ may also depend on $t$.)
We would like to find the probability that 
a lineage which we sample at location $x$ on background $z$,
derived from background $A$ $\tau$ units of time ago,
which we denote by
$$
q(x,z,\tau,r) = \P^x\{ Z_\tau = A \} .
$$
Also note that by symmetry, we should have that
if $r>0$, then
$$\begin{aligned}
    q(x,z,\tau,r) \to \frac{1}{2} \qquad \text{as } \tau \to \infty .
\end{aligned}$$

Let $f$ be a function from $\R \times \{A,B\} \to \R$.
The process above has generator
$$\begin{aligned}
    Gf(x,z) 
    &:= \partial_t \E^{(x,z)}\left[ f(X_t,Z_t) \right] \vert_{t=0} \\
    &= \begin{cases}
    \grad \log(p(x)) \cdot \grad f(x,A) + \frac{\sigma^2}{2} \Delta f(x,A) + r (1-p(x)) (f(x,B)-f(x,A)) \qquad &\text{if } z=A \\
    \grad \log(1-p(x)) \cdot \grad f(x,B) + \frac{\sigma^2}{2} \Delta f(x,B) + r p(x) (f(x,A)-f(x,B)) \qquad &\text{if } z=B .
    \end{cases}
\end{aligned}$$

We know that 
$$\begin{aligned}
q(x,A,0,r) &= 1  \\
q(x,B,0,r) &= 0  \\
\end{aligned}$$
and that $\partial_t q = G q$, i.e.,
(writing $q(x,A,t,r) = q_A(x,t)$ for the moment):
$$\begin{aligned}
    \partial_t q_A(x,t)
        &= 
        \grad \log(p(x)) \cdot \grad q_A(x,t) + \frac{\sigma^2}{2} \Delta q_A(x,t) + r (1-p(x)) (q_B(x,t)-q_A(x,t)) \\
    \partial_t q_B(x,t)
        &= 
        \grad \log(1-p(x)) \cdot \grad q_B(x,t) + \frac{\sigma^2}{2} \Delta q_B(x,t) + r p(x) (q_A(x,t)-q_B(x,t)) .
\end{aligned}$$

The cline shape
---------------

The PDE above gives probabilities given the initial background,
so therefore *linkage* to the selected site.
For the cline shape we need to average over choice of background,
which we denote
$$\begin{aligned}
p(x,\tau,r) =  p(x,\tau) q(x,A,\tau,r) + (1-p(x,\tau))q(x,B,\tau,r) .
\end{aligned}$$
Note that
$$\begin{aligned}
q(x,A,\tau,r) &= 1-q(-x,B,\tau,r) \\
p(x,\tau) &= 1-p(-x,\tau) 
\end{aligned}$$
and so
$$\begin{aligned}
p(x,\tau,r) =  p(x,\tau) q(x,A,\tau,r) + p(-x,\tau) (1-q(-x,A,\tau,r)) .
\end{aligned}$$




Paving the way for analytic approximations
------------------------------------------

Note that $p$ appears twice here:
first pushing lineages, and second causing recombination.
We may want to decouple these for the purposes of approximation:
we'll consider the following system of PDE:
$$\begin{aligned}
    \partial_t q_A(x,t)
        &= 
        \grad \log(u(x)) \cdot \grad q_A(x,t) + \frac{\sigma^2}{2} \Delta q_A(x,t) + r (1-v(x)) (q_B(x,t)-q_A(x,t)) \\
    \partial_t q_B(x,t)
        &= 
        \grad \log(1-u(x)) \cdot \grad q_B(x,t) + \frac{\sigma^2}{2} \Delta q_B(x,t) + r v(x) (q_A(x,t)-q_B(x,t)) \\
    q_A(x,0) &= 1 \\
    q_A(x,t) &= 1-q_B(-x,t) .
\end{aligned}$$

Here's a function to solve this numerically:
```{r solve_pde_setup, cache=TRUE}
thegrid <- setup.grid.1D(x.up=-100, x.down=100, N = 5000)
log_u <- function(x,...){ tanh_cline(x=-x,...,log=TRUE) }
log_1mu <- function(x,...){ tanh_cline(x=x,...,log=TRUE) }
cline_from_soln
solve_pde
```


Numerical solutions
-------------------

Let's solve this numerically.
```{r solve_pde, cache=TRUE, dependson="solve_pde_setup"}
r <- 0.1
s <- 0.1
sigma <- 5
zone.age <- 200  # this is tau
tt <- seq(0,zone.age,length.out=100)
pde.soln <- solve_pde( u=log_u, um1=log_1mu, r=r, times=tt, 
                  s=s, sigma=sigma, grid=thegrid, log.u=TRUE )
image(pde.soln,legend=TRUE,main=sprintf("q for z=%s, r=%0.3f",c("A","B"),r), yaxt='n', ylab='space',zlim=c(0,1))
axis(2,at=(pretty(thegrid$x.mid)-min(thegrid$x.mid))/diff(range(thegrid$x.mid)),labels=pretty(thegrid$x.mid))
```
These combine to give the predicted cline:
```{r show_pde_cline,cache=TRUE,dependson=c("solve_pde_setup","solve_pde")}
pde.cline <- cline_from_soln(pde.soln,grid=thegrid)
image(pde.cline,legend=TRUE,zlim=c(0,1),main=sprintf("clines, at r=%0.2f",r),yaxt='n')
axis(2,at=(pretty(thegrid$x.mid)-min(thegrid$x.mid))/diff(range(thegrid$x.mid)),labels=pretty(thegrid$x.mid))
# same thing, plotted with lines
clineplot(pde.cline,x=thegrid$x.mid,main=sprintf("clines, at r=%0.2f, up to t=%d",r,zone.age))
```
**Note:** the range should be wide enough these are *going to zero*
at the ends, or else we have to worry about the boundary conditions.

The smaller $r$ is, the slower the per-background probabilities smooth out:
```{r small_r_sim,cache=TRUE}
r <- 0.01
pde.soln <- solve_pde( u=log_u, um1=log_1mu, r=r, times=tt, 
                  s=s, sigma=sigma, grid=thegrid, log.u=TRUE )
image(pde.soln,legend=TRUE,main=sprintf("q for z=%s, r=%0.3f",c("A","B"),r), yaxt='n', ylab='space',zlim=c(0,1))
axis(2,at=(pretty(thegrid$x.mid)-min(thegrid$x.mid))/diff(range(thegrid$x.mid)),labels=pretty(thegrid$x.mid))
pde.cline <- cline_from_soln(pde.soln,grid=thegrid)
layout(1)
clineplot(pde.cline,x=thegrid$x.mid,main=sprintf("clines, at r=%0.2f, up to t=%d",r,zone.age))
```

And, the cline flattens out *very* slowly:
```{r longer_t_sim,cache=TRUE}
r <- 1.0
zone.age <- 2000  # this is tau
tt <- seq(0,zone.age,length.out=100)
pde.soln <- solve_pde( u=log_u, um1=log_1mu, r=r, times=tt, 
                  s=s, sigma=sigma, grid=thegrid, log.u=TRUE )
image(pde.soln,legend=TRUE,main=sprintf("q for z=%s, r=%0.3f",c("A","B"),r), yaxt='n', ylab='space',zlim=c(0,1))
axis(2,at=(pretty(thegrid$x.mid)-min(thegrid$x.mid))/diff(range(thegrid$x.mid)),labels=pretty(thegrid$x.mid))
pde.cline <- cline_from_soln(pde.soln,grid=thegrid)
layout(1)
clineplot(pde.cline,x=thegrid$x.mid,main=sprintf("clines, at r=%0.2f, up to t=%d",r,zone.age))
```


Haplotype lengths
=================

Consider a genomic region $[a,b]$, with $a\le 0\le b$,
with the selected site at 0.
Recombination without coalescence makes the history of this region
a branching process with conserved branching rates.
Each branch is labeled by a region of the genome,
and moves independently according to generator $G_r$, 
where $r$ is the distance from the region to the selected site,
and branches at rate $w$, where $w$ is its width.
We would like to know the probability that 
*all* branches end up on the same side of the barrier at time $\tau$ in the past.

Suppose that the region includes a type $A$ allele,
and we want the probability that it inherits entirely from the $A$ side.
Let
$$\begin{aligned}
    g(x,A,a,b,\tau) = \P^{x,A}\{ [a,b] \text{ inherits from $A$, $\tau$ generations ago }\} .
\end{aligned}$$
If $W(t)=\{W_1(t),W_2(t),\ldots,W_{n(t)}(t)\}$ is the state of the process $t$ generations ago,
where $W_k=(x_k,z_k,a_k,b_k)$,
with $x_k$ the position and $W_k\in\{A,B\}$ the allele,
then by independence of branches,
$$\begin{aligned}
    g(x,A,a,b,0) &= 1 \\
    g(x,B,a,b,0) &= 0 \\
    g(x,B,a,b,\tau) &= 0 \qquad \text{if } 0 \in [a,b] \\
    g(x,A,a,b,\tau)
    &=
    \E\left[
        \prod_{i=1}^{n(t)} g(x_k,z_k,a_k,b_k,\tau-t)
    \right] \qquad \text{for each } t \le \tau .
\end{aligned}$$
Taking $t = \epsilon$ in the last equation,
so that the probability of branching is $1-e^{-(b-a)\epsilon}=\epsilon(b-a)+O(\epsilon^2)$,
if $0\le a < b$ this is
$$\begin{aligned}
g(x,A,a,b,\tau)
    &=
    \epsilon 
    \left\{
    G_{r(a,b)} g(x,A,a,b,\tau)
    +
     \int_a^b g(x,A,a,\theta,\tau-\epsilon)
     \left(
     p(x,\tau-\epsilon)g(x,A,\theta,b,\tau-\epsilon) 
     + (1-p(x,\tau-\epsilon))g(x,B,\theta,b,\tau-\epsilon) 
     \right)d\theta
    \right\}
    + O(\epsilon^2),
\end{aligned}$$
where 
$$\begin{aligned}
r(a,b)=\begin{cases}
    \min(|a|,|b|) \qquad &\text{if } ab \ge 0 \\
    0 \qquad &\text{if } 0 \in [a,b] .
\end{cases}
\end{aligned}$$
and $G_r f(x,z)$ is defined above.
On the other hand, if $a<0<b$, then
$$\begin{aligned}
g(x,A,a,b,\tau)
    &=
    \epsilon 
    \left\{
    G_{r(a,b)} g(x,A,a,b,\tau)
    +
     \int_0^b g(x,A,a,\theta,\tau-\epsilon)
     \left(
     p(x,\tau-\epsilon)g(x,A,\theta,b,\tau-\epsilon)
     + (1-p(x,\tau-\epsilon))g(x,B,\theta,b,\tau-\epsilon) 
     \right)d\theta
    +
     \int_a^0 \left(
     p(x,\tau-\epsilon)g(x,A,a,\theta,\tau-\epsilon)
     + (1-p(x,\tau-\epsilon))g(x,B,a,\theta,\tau-\epsilon) 
     \right) g(x,A,\theta,b,\tau-\epsilon) d\theta
    \right\}
    + O(\epsilon^2),
\end{aligned}$$


Therefore, assuming $G$ is sufficiently nice,
$$\begin{aligned}
\frac{d}{d\tau} g(x,z,a,b,\tau)
&=
G_{r(a,b)} g(x,z,a,b,\tau)
+
\int_a^b
\left(
    g(x,z,a,\theta,\tau)g(x,z,\theta,b,\tau) 
    - g(x,z,a,b,\tau)
\right)
d\theta
\end{aligned}$$
Since $z \in \{A,B\}$, this is a system of two integro-differential equations 
in three variables plus time ($x$, $a$, $b$, and $\tau$; four if $x\in\R^2$).

Numerical solutions will discretize; what discretization of the genome might be good?
If we want to solve out to time $\tau$,
then on a chromosome of length 1 there will be about $\tau$ breakpoints,
each of which approximately Exponential($\tau$),
and so the smallest distance will have mean $1/\tau^2$.
But, suppose we've solved it for time $\tau$, and want to solve it to time $2\tau$.
We can use the same discretization, with initial conditions from the first round.
<!--
Quick check:
```{r smallest_check}
f <- function (t) { min(diff(c(0,sort(runif(rpois(1,lambda=t))),1))) }
fk <- sapply( 2:200, function (k) { replicate(n=100,f(k)) } )
plot(1+col(fk),fk,col=rainbow(300)[col(fk)],log='y',ylab='smallest interval')
points(2:200,colMeans(fk),pch=20,cex=2)
lines(2:200,1/(2:200)^2,col='purple',lwd=2)
```
-->

Note that if we think of $u(a,b)$ as a kernel, 
then the map $u(a,b) \mapsto \int_a^b u(a,\theta) u(\theta,b) d\theta$
is similar to the product of the kernel to itself;
on discretization this becomes like a matrix power.
This is implemented in some C code.
```{r solve_branching}
source("unifprod.R")  # for the C part
integral_map <- function (x,eps) {
    # the discretization of the map y(a,b) -> \int_a^b (h(a,u)*h(u,b)-h(a,b)) du
    # x is a square matrix,
    #   eps is the grid spacing between locations
    x2 <- eps*unifprod(x)
}
xgrid <- setup.grid.1D(x.up=-20, x.down=20, N=100)
agrid <- setup.grid.1D(x.up=-0.5, x.down=0.5, N=30)
# we'll save the solution as an array,
#  with dimensions (x,a,b)
# Note we only use the upper triangle a<=b, but oh well.
soln.array <- array(0.0,dim=c(xgrid$N,agrid$N,agrid$N))

# determines the order the solution is in:
xab <- subset( expand.grid( x=xgrid$x.mid, a=agrid$x.mid, b=agrid$x.mid ), ( b>0 ) & (abs(a)<=abs(b)) )
find_ab <- function (ab) {
    # map into the subset of (a,b) contained in xab
    flip <- ab[,1]>ab[,2] 
    ab[flip,] <- ab[flip,] %*% cbind( c(0,1), c(1,0) )
    flop <- ( ab[,1]<0 & abs(ab[,1])>=abs(ab[,2]) )
    ab[flop,] <- ab[flop,] %*% cbind( c(0,-1), c(-1,0) )
    return(ab)
}
```



Distance to closest recombination in a heterozygote
---------------------------------------------------

A simpler statistic, that might approximate the correct quantity well,
is the distance along the chromosome from an $A$ allele until the closest recombination
that occurred in an $AB$ heterozygote.
Let $H$ be this distance;
then, 
$$\begin{aligned}
    u(x,\tau,r)=\P^{(x,\tau)}\{H>r\}
\end{aligned}$$
solves the following PDE:
$$\begin{aligned}
    u(x,0,r) &= 1  \\
    \partial_t u(x,t,r)
        &= 
        \grad \log(p(x)) \cdot \grad u(x,t,r) + \frac{\sigma^2}{2} \Delta u(x,t,r) - r (1-p(x)) u(x,t,r) .
\end{aligned}$$




Comparison to simulation
========================

We'll setup, run, and summarize simulations
as described in [this file](../sims/run-sims.html).
```{r setup_sims, cache=TRUE}
source("../sims/sim-fns.R")
zone.age    = 50
ndemes 		= 500
deme.size 	= 5
ninds 		= ndemes*deme.size
qtl         = list(chr1=data.frame(traits=c("underdominant"), s = s, pos=c(0.5)))
# spatial locations
xx <- (1:ndemes)-0.5-ndemes/2
# run the simulation
sim <- sim.zone(n.gen=zone.age,n.ind=ninds,n.deme=ndemes,sigma=sigma,quiet=TRUE)
# post-process
sim.sums <- spBreaks(sim)
```
and, postprocess:
```{r genotype_sims, cache=TRUE, dependson="setup_sims"}
rvals <- c(0,exp(seq(log(.001),log(0.5),length.out=10)))
loci <- list(0.5+c(rev(rvals[-1]),-rvals))
genotypes <- data.frame(do.call(cbind,lapply(sim.sums$ind.ancest, geno.ind, loci)))
freqs <- apply(genotypes,1,function(Z){
            tapply(Z,cut(1:ncol(genotypes),breaks=seq(0,ncol(genotypes),deme.size)),mean)/2
        })
```

OK, now let's match the PDE solution to the simulation.
First, does the cline at the selected locus match the the tanh cline?
```{r match_cline}
plot(xx,freqs[,1],type='l',xlab="spatial location",ylab="proportion")
lines(xx,1-tanh_cline(xx,s=s,sigma=sigma),col='red')
```
Looks pretty reasonable.

Here's the PDE solution:
```{r match_pde,cache=TRUE,dependson="solve_pde_setup"}
zone.age <- sim$pars["n.gen"]
tt <- seq(0,zone.age,length.out=100)
pde.solns <- lapply(rvals, function (r) { solve_pde( u=log_u, um1=log_1mu, r=r, times=tt, 
                                                s=s, sigma=sigma, grid=thegrid, log.u=TRUE ) } )
pde.clines <- lapply( pde.solns, cline_from_soln, grid=thegrid )
match.clines <- sapply(pde.clines,function(x)x[length(tt),-1])
for (k in floor(seq(2,length(rvals),length.out=3))) {
    image(pde.solns[[k]],legend=TRUE,main=sprintf("r=%f",rvals[k]))
}
```
Now, comparing the PDE solution to the others:
```{r match_cline_pde}
for (k in seq_along(rvals)) {
    matplot(xx,freqs[,which(abs(rvals[k]-loci[[1]]+0.5)<1e-9)],type='l',
            xlab="spatial location",ylab="proportion",main=sprintf("r=%0.3f",rvals[k]))
    lines(xx,1-tanh_cline(xx,s=s,sigma=sigma),col='red',lwd=3,lty=3)
    lines(1-thegrid$x.mid,match.clines[,k],col='green',lwd=3)
}
```
