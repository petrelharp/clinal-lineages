---
title: "Clines from PDE"
date: "`r date()`"
---

$$
\newcommand{\E}{\mathbb{E}}
\renewcommand{\P}{\mathbb{P}}
\newcommand{\R}{\mathbb{R}}
\DeclareMathOperator{\sgn}{sgn}
\newcommand{\grad}{\nabla}
$$

```{r doc_setup, include=FALSE}
fig.dim <- 5
knitr::opts_chunk$set(fig.width=2*fig.dim,fig.height=fig.dim,fig.align='center')
library(ReacTran)
source("tran.1D.R") # fix for log.A
```

*Useful functions used below:*
```{r setup_fns}
source("cline-fns.R")
```

The goal
========


Suppose that a lineage moves in a frequency profile $p(x)$ of allele $A$,
switching between backgrounds at rate $r p(x)$ or $r (1-p(x))$.
Let $(X_t,Z_t)$ denote this process,
so that
$$\begin{aligned}
    dX_t &= \grad \log(p(X_t)) dt + dB_t  \qquad \text{if } Z_t = A \\
         &= \grad \log(1-p(X_t)) dt + dB_t  \qquad \text{if } Z_t = B \\
    \P\{ Z_{t+\epsilon} = B | Z_t = A \} &= \epsilon r (1-p(X_t)) + O(\epsilon^2) \\
    \P\{ Z_{t+\epsilon} = A | Z_t = B \} &= \epsilon r p(X_t) + O(\epsilon^2) .
\end{aligned}$$
(Note that $p$ may also depend on $t$.)
We would like to find the probability that 
a lineage which we sample at location $x$ on background $z$,
derived from background $A$ $\tau$ units of time ago,
which we denote by
$$
q(x,z,\tau,r) = \P^x\{ Z_\tau = A \} .
$$
(Note that this gives us linkage to the selected site,
and for the cline shape we only need $p(x,\tau) q(x,A,\tau,r) + (1-p(x,\tau))q(x,B,\tau,r)$,
but it is easier to compute this.)
Also note that by symmetry, we should have that
if $r>0$, then
$$\begin{aligned}
    q(x,z,\tau,r) \to \frac{1}{2} \qquad \text{as } \tau \to \infty .
\end{aligned}$$

Let $f$ be a function from $\R \times \{A,B\} \to \R$.
The process above has generator
$$\begin{aligned}
    Gf(x,z) 
    &:= \partial_t \E^{(x,z)}\left[ f(X_t,Z_t) \right] \vert_{t=0} \\
    &= \begin{cases}
    \grad \log(p(x)) \cdot \grad f(x,A) + \frac{\sigma^2}{2} \Delta f(x,A) + r (1-p(x)) (f(x,B)-f(x,A)) \qquad &\text{if } z=A \\
    \grad \log(1-p(x)) \cdot \grad f(x,B) + \frac{\sigma^2}{2} \Delta f(x,B) + r p(x) (f(x,A)-f(x,B)) \qquad &\text{if } z=B .
    \end{cases}
\end{aligned}$$

We know that 
$$\begin{aligned}
q(x,A,0,r) = 1  \\
q(x,B,0,r) = 0  \\
\end{aligned}$$
and that $\partial_t q = G q$, i.e.,
(writing $q(x,A,t,r) = q_A(x,t)$ for the moment):
$$\begin{aligned}
    \partial_t q_A(x,t)
        &= 
        \grad \log(p(x)) \cdot \grad q_A(x,t) + \frac{\sigma^2}{2} \Delta q_A(x,t) + r (1-p(x)) (q_B(x,t)-q_A(x,t)) \\
    \partial_t q_B(x,t)
        &= 
        \grad \log(1-p(x)) \cdot \grad q_B(x,t) + \frac{\sigma^2}{2} \Delta q_B(x,t) + r p(x) (q_A(x,t)-q_B(x,t)) .
\end{aligned}$$

Paving the way for analytic approximations
------------------------------------------

Note that $p$ appears twice here:
first pushing lineages, and second causing recombination.
We may want to decouple these for the purposes of approximation:
we'll consider the following system of PDE:
$$\begin{aligned}
    \partial_t q_A(x,t)
        &= 
        \grad \log(u(x)) \cdot \grad q_A(x,t) + \frac{\sigma^2}{2} \Delta q_A(x,t) + r (1-v(x)) (q_B(x,t)-q_A(x,t)) \\
    \partial_t q_B(x,t)
        &= 
        \grad \log(1-u(x)) \cdot \grad q_B(x,t) + \frac{\sigma^2}{2} \Delta q_B(x,t) + r v(x) (q_A(x,t)-q_B(x,t)) \\
    q_A(x,0) &= 1 \\
    q_A(x,t) &= 1-q_B(-x,t) .
\end{aligned}$$

Here's a function to solve this numerically:
```{r solve_pde_setup, cache=TRUE}
thegrid <- setup.grid.1D(x.up=-100, x.down=100, N = 5000)
log_u <- function(x,...){ tanh_cline(x=-x,...,log=TRUE) }
log_1mu <- function(x,...){ tanh_cline(x=x,...,log=TRUE) }
cline.from.soln
solve.pde
```


Numerical solutions
-------------------

Let's solve this numerically.
```{r solve_pde, cache=TRUE, depends="solve_pde_setup"}
r <- 0.1
s <- 0.1
sigma <- 10
zone.age <- 200  # this is tau
tt <- seq(0,zone.age,length.out=100)
pde.soln <- solve.pde( u=log_u, um1=log_1mu, r=r, times=tt, 
                  s=s, sigma=sigma, grid=thegrid, log.u=TRUE )
image(pde.soln,legend=TRUE,main=sprintf("q for z=%s, r=%0.3f",c("A","B"),r), yaxt='n', ylab='space',zlim=c(0,1))
axis(2,at=(pretty(thegrid$x.mid)-min(thegrid$x.mid))/diff(range(thegrid$x.mid)),labels=pretty(thegrid$x.mid))
```
These combine to give the predicted cline:
```{r show_pde_cline,cache=TRUE,depends=c("solve_pde_setup","solve_pde")}
pde.cline <- cline.from.soln(pde.soln,grid=thegrid)
image(pde.cline,legend=TRUE,zlim=c(0,1),main=sprintf("clines, at r=%0.2f",r))
# same thing, plotted with lines
clineplot(pde.cline,x=thegrid$x.mid,main=sprintf("clines, at r=%0.2f, up to t=%d",r,zone.age))
```
**Note:** the range should be wide enough these are *going to zero*
at the ends, or else we have to worry about the boundary conditions.

The smaller $r$ is, the slower the per-background probabilities smooth out:
```{r small_r_sim}
r <- 0.01
pde.soln <- solve.pde( u=log_u, um1=log_1mu, r=r, times=tt, 
                  s=s, sigma=sigma, grid=thegrid, log.u=TRUE )
image(pde.soln,legend=TRUE,main=sprintf("q for z=%s, r=%0.3f",c("A","B"),r), yaxt='n', ylab='space',zlim=c(0,1))
axis(2,at=(pretty(thegrid$x.mid)-min(thegrid$x.mid))/diff(range(thegrid$x.mid)),labels=pretty(thegrid$x.mid))
pde.cline <- cline.from.soln(pde.soln,grid=thegrid)
clineplot(pde.cline,x=thegrid$x.mid,main=sprintf("clines, at r=%0.2f, up to t=%d",r,zone.age))
```

And, the cline flattens out *very* slowly:
```{r longer_t_sim}
r <- 0.1
zone.age <- 2000  # this is tau
tt <- seq(0,zone.age,length.out=100)
pde.soln <- solve.pde( u=log_u, um1=log_1mu, r=r, times=tt, 
                  s=s, sigma=sigma, grid=thegrid, log.u=TRUE )
image(pde.soln,legend=TRUE,main=sprintf("q for z=%s, r=%0.3f",c("A","B"),r), yaxt='n', ylab='space',zlim=c(0,1))
axis(2,at=(pretty(thegrid$x.mid)-min(thegrid$x.mid))/diff(range(thegrid$x.mid)),labels=pretty(thegrid$x.mid))
pde.cline <- cline.from.soln(pde.soln,grid=thegrid)
clineplot(pde.cline,x=thegrid$x.mid,main=sprintf("clines, at r=%0.2f, up to t=%d",r,zone.age))
```
This should be symmetric.  Let's check:
```{r check_symmetry}
pde.soln <- solve.pde( um1=log_u, u=log_1mu, r=r, times=tt, 
                yinit=c( rep(1.0,thegrid$N), rep(0.0,thegrid$N) ),
                s=s, sigma=sigma, grid=thegrid, log.u=TRUE )
image(pde.soln,legend=TRUE,main=sprintf("q for z=%s, r=%0.3f",c("A","B"),r), yaxt='n', ylab='space',zlim=c(0,1))
axis(2,at=(pretty(thegrid$x.mid)-min(thegrid$x.mid))/diff(range(thegrid$x.mid)),labels=pretty(thegrid$x.mid))
pde.cline <- cline.from.soln(pde.soln,grid=thegrid)
clineplot(pde.cline,x=thegrid$x.mid,main=sprintf("clines, at r=%0.2f, up to t=%d",r,zone.age))
```



Comparison to simulation
========================

We'll setup, run, and summarize simulations
as described in [this file](../sims/run-sims.html).
```{r setup_sims, cache=TRUE}
source("../sims/sim-fns.R")
ndemes 		= 500
deme.size 	= 5
ninds 		= ndemes*deme.size
qtl         = list(chr1=data.frame(traits=c("underdominant"), s = s, pos=c(0.5)))
# spatial locations
xx <- (1:ndemes)-0.5-ndemes/2
# run the simulation
sim <- sim.zone(n.gen=zone.age,n.ind=ninds,n.deme=ndemes,sigma=sigma,quiet=TRUE)
# post-process
sim.sums <- spBreaks(sim)
```
and, postprocess:
```{r genotype_sims, cache=TRUE, depends="setup_sims"}
rvals <- c(0,exp(seq(log(.001),log(0.5),length.out=10)))
loci <- list(0.5+rvals)
genotypes <- data.frame(do.call(cbind,lapply(sim.sums$ind.ancest, geno.ind, loci)))
freqs <- apply(genotypes,1,function(Z){
            tapply(Z,cut(1:ncol(genotypes),breaks=seq(0,ncol(genotypes),deme.size)),mean)/2
        })
```

OK, now let's match the PDE solution to the simulation.
First, does the cline at the selected locus match the the tanh cline?
```{r match_cline}
plot(xx,freqs[,1],type='l',xlab="spatial location",ylab="proportion")
lines(xx,1-tanh_cline(xx,s=s,sigma=sigma),col='red')
```
Looks pretty reasonable.

Here's the PDE solution:
```{r match_pde,cache=TRUE,depends="solve_pde_setup"}
tt <- seq(0,zone.age,length.out=100)
pde.solns <- lapply(rvals, function (r) { solve.pde( u=log_u, um1=log_1mu, r=r, times=tt, 
                                                s=s, sigma=sigma, grid=thegrid, log.u=TRUE ) } )
pde.clines <- lapply( pde.solns, cline.from.soln, grid=thegrid )
match.clines <- sapply(pde.clines,function(x)x[length(tt),-1])
for (k in floor(seq(1,length(rvals),length.out=3))) {
    image(pde.solns[[k]],legend=TRUE,main=sprintf("r=%f",rvals[k]))
}
```
Now, comparing the PDE solution to the others:
```{r match_cline_pde}
for (k in seq_along(rvals)) {
    plot(xx,freqs[,k],type='l',xlab="spatial location",ylab="proportion",main=sprintf("r=%0.3f",rvals[k]))
    lines(xx,1-tanh_cline(xx,s=s,sigma=sigma),col='red',lwd=3,lty=3)
    lines(1-thegrid$x.mid,match.clines[,k],col='green',lwd=3)
}
```
